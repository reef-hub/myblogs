# dp五部曲

1、确定dp数组以及下标的含义
2、确定递推公式
3、dp数组如何初始化
4、确定遍历顺序
5、举例推导dp数组

# 题目

## 1、斐波那契数
0 1 1 2 3 5 8 13 21 34 55
用1维dp数组来保存结果即可
1、确定dp数组以及下标的含义
dp[i]:第i个数的斐波那契数值是dp[i]
2、确定递推公式
题意已给出：dp[i] = dp[i-1] + dp[i-2]
3、dp数组如何初始化
```cpp
dp[0] = 0;
dp[1] = 1
```
4、确定遍历顺序
dp[i]是依赖dp[i-1]和dp[i-2]，那么遍历的顺序是从前到后遍历的
5、举例推导dp数组
如果代码写出来，发现不对，就把dp数组打印出来看看和我们推导的数列是不是一致的。

## 2、爬楼梯

假设你正在爬楼梯。需要 n 阶你才能到达楼顶。
每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？
注意：给定 n 是一个正整数。

用1维数组来保存结果即可
1、dp[i]:第i个台阶的攀爬方法有dp[i]种
2、dp[i] = dp[i-1] + dp[i-2]
3、初始化
```cpp
dp[1] = 1;
dp[2] = 2;
```
4、确定遍历顺序
当前值依赖历史值，故从前向后遍历
5、举例推导dp数组（debug）

## 3、使用最小花费爬楼梯

数组的每个下标作为一个阶梯，第 i 个阶梯对应着一个非负数的体力花费值 cost[i]（下标从 0 开始）。
每当你爬上一个阶梯你都要花费对应的体力值，一旦支付了相应的体力值，你就可以选择向上爬一个阶梯或者爬两个阶梯。
请你找出达到楼层顶部的最低花费。在开始时，你可以选择从下标为 0 或 1 的元素作为初始阶梯。

### 分析

从第i阶台阶起步需要花费体力，花费的体力与起步的台阶有关，而与到达的台阶无关
从第i阶起步后，扣除相应体力cost[i]后，可以选择向上1或2阶

1、dp[i]:到达第i个台阶花费的最小体力
2、dp[i] = min(dp[i-1] + cost[i-1], dp[i-2] + cost[i-2])
3、初始化
```cpp
dp[0] = 0;
dp[1] = 0;
```
4、确定遍历顺序
当前值依赖历史值，故从前向后遍历
5、举例推导dp数组（debug）

## 4、不同路径

一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。
机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。
问总共有多少条不同的路径？

### （1）dfs
这道题目，刚一看最直观的想法就是用图论里的深搜，来枚举出来有多少种路径。
注意题目中说机器人每次只能向下或者向右移动一步，那么其实机器人走过的路径可以抽象为一棵二叉树，而叶子节点就是终点！
此时问题就可以转化为求二叉树叶子节点的个数，代码如下：
```cpp
class Solution {
private:
    int dfs(int i, int j, int m, int n) {
        if (i > m || j > n) return 0; // 越界了
        if (i == m && j == n) return 1; // 找到一种方法，相当于找到了叶子节点
        return dfs(i + 1, j, m, n) + dfs(i, j + 1, m, n);
    }
public:
    int uniquePaths(int m, int n) {
        return dfs(1, 1, m, n);
    }
};
```
但会超时

### （2）dp
#### 用二维数组来保存结果
从（0，0）出发，到终点（m-1，n-1）
1、确定dp数组的下标及含义
dp[i][j]:表示从（0，0）出发，到（i，j）的不同路径数量。
2、确定递推公式
dp[i][j] = dp[i-1][j] + dp[i][j-1]
3、初始化
```cpp
for (int i = 0; i < m; i++) dp[i][0] = 1;
for (int j = 0; j < n; j++) dp[0][j] = 1;
```
4、确定遍历顺序
从左向右，从上向下
5、举例推导
用于debug

#### 用1维数组来保存结果
用2维数组保存结果时，自上而下计算时，前一行的数据只用于计算后一行的数据，之后无用处
所以可以降dp为1维数组
1、dp[j]:表示从（0，0）出发，到（m-1, j）的不同路径数量
2、dp[j] = dp[j-1] + dp[j]
3、初始化
```cpp
vector<int> dp(n,1);
```
4、从左向右遍历
```cpp
while(m--) {
    for(int j = 1; j < n; j++) {
        dp[j] = dp[j-1] + dp[j];
    }
}
```
5、举例推导(用于debug)

## 5、整数拆分
给定一个正整数 n，将其拆分为至少两个正整数的和，并使这些整数的乘积最大化。 返回你可以获得的最大乘积。
示例：
输入: 10
输出: 36
解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36。
说明: 你可以假设 n 不小于 2 且不大于 58。

1、dp[i]:分拆数字i，可以得到的最大乘积
2、dp[i] = max(dp[i], max((i - j) * j, dp[i - j] * j));
3、初始化
```cpp
dp[2] = 1;
```
4、遍历顺序
dp[i] 是依靠 dp[i - j]的状态，所以遍历i一定是从前向后遍历，先有dp[i - j]再有dp[i]。
完整代码
```cpp
class Solution {
public:
    int integerBreak(int n) {
        vector<int> dp(n + 1);
        dp[2] = 1;
        for (int i = 3; i <= n ; i++) {
            for (int j = 1; j < i - 1; j++) {
                dp[i] = max(dp[i], max((i - j) * j, dp[i - j] * j));
            }
        }
        return dp[n];
    }
};
```

## 6、不同的二叉搜索树

给定一个整数 n，求以 1 ... n 为节点组成的二叉搜索树有多少种？
![](pictures/Different_binary_search_trees.png)

### 分析
dp[3]，就是 元素1为头结点搜索树的数量 + 元素2为头结点搜索树的数量 + 元素3为头结点搜索树的数量
元素1为头结点搜索树的数量 = 右子树有2个元素的搜索树数量 * 左子树有0个元素的搜索树数量
元素2为头结点搜索树的数量 = 右子树有1个元素的搜索树数量 * 左子树有1个元素的搜索树数量
元素3为头结点搜索树的数量 = 右子树有0个元素的搜索树数量 * 左子树有2个元素的搜索树数量
有2个元素的搜索树数量就是dp[2]。
有1个元素的搜索树数量就是dp[1]。
有0个元素的搜索树数量就是dp[0]。
所以dp[3] = dp[2] * dp[0] + dp[1] * dp[1] + dp[0] * dp[2]

1、dp[i]:1到i为节点组成的二叉搜索树数量
2、递推关系
```cpp
for(int i=2; i<=n; i++) {
    for(int j = 0; j<=i-1; j++){
        dp[i] += dp[j]*dp[i-j-1];
    }
}
```
3、dp[0] = 1;dp[1] = 1;
4、从前向后